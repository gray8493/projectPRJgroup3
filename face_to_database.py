#!/usr/bin/env python3
"""
·ª®ng d·ª•ng qu√©t khu√¥n m·∫∑t v√† l∆∞u d·ªØ li·ªáu v√†o MySQL database
"""

import cv2
import numpy as np
import mysql.connector
from datetime import datetime
import json
import hashlib

class FaceDatabaseSystem:
    def __init__(self):
        """Kh·ªüi t·∫°o h·ªá th·ªëng qu√©t khu√¥n m·∫∑t v√† database"""
        # Load face detector
        self.face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
        
        # Database connection
        self.db_connection = None
        self.cursor = None
        
        # ƒê·ªãnh nghƒ©a c√°c nh√≥m tu·ªïi
        self.age_groups = {
            0: 'Tr·∫ª em (0-12)',
            1: 'Thi·∫øu ni√™n (13-17)', 
            2: 'Thanh ni√™n (18-25)',
            3: 'Tr∆∞·ªüng th√†nh (26-35)',
            4: 'Trung ni√™n (36-50)',
            5: 'Cao tu·ªïi (50+)'
        }
    
    def connect_database(self, host='localhost', user='root', password='', database='face_recognition'):
        """K·∫øt n·ªëi ƒë·∫øn MySQL database"""
        try:
            self.db_connection = mysql.connector.connect(
                host=host,
                user=user,
                password=password,
                database=database
            )
            self.cursor = self.db_connection.cursor()
            print("‚úÖ ƒê√£ k·∫øt n·ªëi database th√†nh c√¥ng!")
            return True
        except mysql.connector.Error as err:
            print(f"‚ùå L·ªói k·∫øt n·ªëi database: {err}")
            return False
    
    def create_database_tables(self):
        """T·∫°o b·∫£ng trong database n·∫øu ch∆∞a c√≥"""
        try:
            # T·∫°o b·∫£ng face_scans
            create_table_query = """
            CREATE TABLE IF NOT EXISTS face_scans (
                id INT AUTO_INCREMENT PRIMARY KEY,
                scan_time DATETIME NOT NULL,
                face_count INT NOT NULL,
                session_id VARCHAR(50) NOT NULL,
                location VARCHAR(100),
                notes TEXT
            )
            """
            self.cursor.execute(create_table_query)
            
            # T·∫°o b·∫£ng face_data
            create_face_data_query = """
            CREATE TABLE IF NOT EXISTS face_data (
                id INT AUTO_INCREMENT PRIMARY KEY,
                scan_id INT,
                face_number INT NOT NULL,
                age_group VARCHAR(50) NOT NULL,
                age_confidence FLOAT,
                face_width INT NOT NULL,
                face_height INT NOT NULL,
                face_area INT NOT NULL,
                position_x INT NOT NULL,
                position_y INT NOT NULL,
                texture_variance FLOAT,
                contrast_level FLOAT,
                edge_density FLOAT,
                smoothness FLOAT,
                face_hash VARCHAR(64),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (scan_id) REFERENCES face_scans(id)
            )
            """
            self.cursor.execute(create_face_data_query)
            
            self.db_connection.commit()
            print("‚úÖ ƒê√£ t·∫°o b·∫£ng database th√†nh c√¥ng!")
            return True
            
        except mysql.connector.Error as err:
            print(f"‚ùå L·ªói t·∫°o b·∫£ng: {err}")
            return False
    
    def analyze_face_features(self, face_region):
        """Ph√¢n t√≠ch ƒë·∫∑c tr∆∞ng khu√¥n m·∫∑t"""
        gray_face = cv2.cvtColor(face_region, cv2.COLOR_BGR2GRAY)
        h, w = gray_face.shape
        
        features = {}
        
        # K√≠ch th∆∞·ªõc v√† di·ªán t√≠ch
        features['width'] = w
        features['height'] = h
        features['area'] = w * h
        
        # Ph√¢n t√≠ch texture
        laplacian = cv2.Laplacian(gray_face, cv2.CV_64F)
        features['texture_variance'] = float(laplacian.var())
        
        # ƒê·ªô t∆∞∆°ng ph·∫£n
        features['contrast'] = float(gray_face.std())
        
        # M·∫≠t ƒë·ªô c·∫°nh
        edges = cv2.Canny(gray_face, 50, 150)
        features['edge_density'] = float(np.sum(edges > 0) / (h * w))
        
        # ƒê·ªô m·ªãn
        blur = cv2.GaussianBlur(gray_face, (5, 5), 0)
        features['smoothness'] = float(np.mean(np.abs(gray_face.astype(float) - blur.astype(float))))
        
        return features
    
    def estimate_age_group(self, features):
        """∆Ø·ªõc t√≠nh nh√≥m tu·ªïi"""
        score = 0
        confidence = 0
        
        # Ph√¢n t√≠ch k√≠ch th∆∞·ªõc
        face_area = features['area']
        if face_area < 5000:
            score += 2
            confidence += 0.7
        elif face_area < 10000:
            score += 1
            confidence += 0.6
        elif face_area > 20000:
            score -= 1
            confidence += 0.5
        
        # Ph√¢n t√≠ch texture
        texture = features['texture_variance']
        if texture > 500:
            score += 2
            confidence += 0.8
        elif texture > 200:
            score += 1
            confidence += 0.6
        elif texture < 100:
            score -= 2
            confidence += 0.8
        
        # Ph√¢n t√≠ch contrast
        contrast = features['contrast']
        if contrast > 50:
            score += 1
            confidence += 0.5
        elif contrast < 30:
            score -= 1
            confidence += 0.5
        
        # Ph√¢n t√≠ch edge density
        edge_density = features['edge_density']
        if edge_density < 0.1:
            score += 1
            confidence += 0.6
        elif edge_density > 0.2:
            score -= 1
            confidence += 0.6
        
        # T√≠nh confidence trung b√¨nh
        confidence = min(confidence / 4, 1.0)
        
        # Quy·∫øt ƒë·ªãnh nh√≥m tu·ªïi
        if score >= 4:
            return 0, confidence  # Tr·∫ª em
        elif score >= 2:
            return 1, confidence  # Thi·∫øu ni√™n
        elif score >= 0:
            return 2, confidence  # Thanh ni√™n
        elif score >= -1:
            return 3, confidence  # Tr∆∞·ªüng th√†nh
        elif score >= -2:
            return 4, confidence  # Trung ni√™n
        else:
            return 5, confidence  # Cao tu·ªïi
    
    def generate_face_hash(self, face_region):
        """T·∫°o hash cho khu√¥n m·∫∑t ƒë·ªÉ tr√°nh tr√πng l·∫∑p"""
        gray_face = cv2.cvtColor(face_region, cv2.COLOR_BGR2GRAY)
        # Resize v·ªÅ k√≠ch th∆∞·ªõc chu·∫©n
        resized = cv2.resize(gray_face, (64, 64))
        # T·∫°o hash
        face_bytes = resized.tobytes()
        return hashlib.sha256(face_bytes).hexdigest()
    
    def save_scan_to_database(self, faces_data, location="", notes=""):
        """L∆∞u d·ªØ li·ªáu qu√©t v√†o database"""
        try:
            # T·∫°o session ID
            session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # L∆∞u th√¥ng tin scan ch√≠nh
            scan_query = """
            INSERT INTO face_scans (scan_time, face_count, session_id, location, notes)
            VALUES (%s, %s, %s, %s, %s)
            """
            scan_data = (
                datetime.now(),
                len(faces_data),
                session_id,
                location,
                notes
            )
            
            self.cursor.execute(scan_query, scan_data)
            scan_id = self.cursor.lastrowid
            
            # L∆∞u d·ªØ li·ªáu t·ª´ng khu√¥n m·∫∑t
            face_query = """
            INSERT INTO face_data (
                scan_id, face_number, age_group, age_confidence,
                face_width, face_height, face_area,
                position_x, position_y,
                texture_variance, contrast_level, edge_density, smoothness,
                face_hash
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            for i, face_data in enumerate(faces_data):
                face_values = (
                    scan_id,
                    i + 1,
                    face_data['age_group'],
                    float(face_data['confidence']),
                    int(face_data['features']['width']),
                    int(face_data['features']['height']),
                    int(face_data['features']['area']),
                    int(face_data['position'][0]),
                    int(face_data['position'][1]),
                    float(face_data['features']['texture_variance']),
                    float(face_data['features']['contrast']),
                    float(face_data['features']['edge_density']),
                    float(face_data['features']['smoothness']),
                    face_data['face_hash']
                )
                
                self.cursor.execute(face_query, face_values)
            
            self.db_connection.commit()
            
            print(f"‚úÖ ƒê√£ l∆∞u {len(faces_data)} khu√¥n m·∫∑t v√†o database!")
            print(f"üìä Session ID: {session_id}")
            print(f"üÜî Scan ID: {scan_id}")
            
            return scan_id, session_id
            
        except mysql.connector.Error as err:
            print(f"‚ùå L·ªói l∆∞u database: {err}")
            return None, None
    
    def scan_faces_live(self):
        """Qu√©t khu√¥n m·∫∑t tr·ª±c ti·∫øp t·ª´ camera"""
        print("üìπ Kh·ªüi ƒë·ªông camera ƒë·ªÉ qu√©t khu√¥n m·∫∑t...")
        
        cap = cv2.VideoCapture(0)
        
        if not cap.isOpened():
            print("‚ùå Kh√¥ng th·ªÉ m·ªü camera!")
            return
        
        print("‚úÖ Camera ƒë√£ s·∫µn s√†ng!")
        print("üí° Nh·∫•n SPACE ƒë·ªÉ qu√©t v√† l∆∞u v√†o database, ESC ƒë·ªÉ tho√°t")
        
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            
            # Ph√°t hi·ªán khu√¥n m·∫∑t
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            faces = self.face_cascade.detectMultiScale(gray, 1.1, 5, minSize=(50, 50))
            
            # V·∫Ω khung khu√¥n m·∫∑t v√† th√¥ng tin
            display_frame = frame.copy()
            for i, (x, y, w, h) in enumerate(faces):
                cv2.rectangle(display_frame, (x, y), (x+w, y+h), (0, 255, 0), 2)
                cv2.putText(display_frame, f'Face {i+1}', (x, y-10), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            
            # Hi·ªÉn th·ªã th√¥ng tin
            info_text = f"Faces: {len(faces)} | SPACE: Save to DB | ESC: Exit"
            cv2.putText(display_frame, info_text, (10, 30), 
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            
            cv2.imshow('Face Scanner - Database Mode', display_frame)
            
            key = cv2.waitKey(1) & 0xFF
            
            if key == 32:  # SPACE
                if len(faces) > 0:
                    print(f"\nüîç ƒêang ph√¢n t√≠ch {len(faces)} khu√¥n m·∫∑t...")
                    
                    faces_data = []
                    
                    for i, (x, y, w, h) in enumerate(faces):
                        # C·∫Øt v√πng khu√¥n m·∫∑t
                        face_region = frame[y:y+h, x:x+w]
                        
                        # Ph√¢n t√≠ch ƒë·∫∑c tr∆∞ng
                        features = self.analyze_face_features(face_region)
                        
                        # ∆Ø·ªõc t√≠nh tu·ªïi
                        age_group_id, confidence = self.estimate_age_group(features)
                        age_group_name = self.age_groups[age_group_id]
                        
                        # T·∫°o hash
                        face_hash = self.generate_face_hash(face_region)
                        
                        # L∆∞u d·ªØ li·ªáu
                        face_data = {
                            'position': (x, y),
                            'age_group': age_group_name,
                            'confidence': confidence,
                            'features': features,
                            'face_hash': face_hash
                        }
                        
                        faces_data.append(face_data)
                        
                        print(f"üë§ Khu√¥n m·∫∑t {i+1}: {age_group_name} ({confidence:.1%})")
                    
                    # Nh·∫≠p th√¥ng tin b·ªï sung
                    location = input("üìç Nh·∫≠p v·ªã tr√≠ (t√πy ch·ªçn): ").strip()
                    notes = input("üìù Nh·∫≠p ghi ch√∫ (t√πy ch·ªçn): ").strip()
                    
                    # L∆∞u v√†o database
                    scan_id, session_id = self.save_scan_to_database(faces_data, location, notes)
                    
                    if scan_id:
                        print("üéâ ƒê√£ l∆∞u th√†nh c√¥ng!")
                    
                else:
                    print("‚ö†Ô∏è Kh√¥ng ph√°t hi·ªán khu√¥n m·∫∑t n√†o!")
                    
            elif key == 27:  # ESC
                break
        
        cap.release()
        cv2.destroyAllWindows()
    
    def view_database_stats(self):
        """Xem th·ªëng k√™ database"""
        try:
            # Th·ªëng k√™ t·ªïng quan
            self.cursor.execute("SELECT COUNT(*) FROM face_scans")
            total_scans = self.cursor.fetchone()[0]
            
            self.cursor.execute("SELECT COUNT(*) FROM face_data")
            total_faces = self.cursor.fetchone()[0]
            
            print(f"\nüìä TH·ªêNG K√ä DATABASE:")
            print("=" * 30)
            print(f"üîç T·ªïng s·ªë l·∫ßn qu√©t: {total_scans}")
            print(f"üë• T·ªïng s·ªë khu√¥n m·∫∑t: {total_faces}")
            
            # Th·ªëng k√™ theo nh√≥m tu·ªïi
            self.cursor.execute("""
                SELECT age_group, COUNT(*) as count 
                FROM face_data 
                GROUP BY age_group 
                ORDER BY count DESC
            """)
            
            age_stats = self.cursor.fetchall()
            
            print(f"\nüéÇ PH√ÇN B·ªê THEO TU·ªîI:")
            for age_group, count in age_stats:
                percentage = (count / total_faces) * 100 if total_faces > 0 else 0
                print(f"   {age_group}: {count} ng∆∞·ªùi ({percentage:.1f}%)")
            
            # L·∫ßn qu√©t g·∫ßn nh·∫•t
            self.cursor.execute("""
                SELECT scan_time, face_count, location 
                FROM face_scans 
                ORDER BY scan_time DESC 
                LIMIT 5
            """)
            
            recent_scans = self.cursor.fetchall()
            
            print(f"\n‚è∞ 5 L·∫¶N QU√âT G·∫¶N NH·∫§T:")
            for scan_time, face_count, location in recent_scans:
                loc_text = f" t·∫°i {location}" if location else ""
                print(f"   {scan_time}: {face_count} khu√¥n m·∫∑t{loc_text}")
                
        except mysql.connector.Error as err:
            print(f"‚ùå L·ªói truy v·∫•n database: {err}")
    
    def close_connection(self):
        """ƒê√≥ng k·∫øt n·ªëi database"""
        if self.cursor:
            self.cursor.close()
        if self.db_connection:
            self.db_connection.close()
        print("‚úÖ ƒê√£ ƒë√≥ng k·∫øt n·ªëi database")

def setup_database():
    """H∆∞·ªõng d·∫´n thi·∫øt l·∫≠p database"""
    print("üóÑÔ∏è THI·∫æT L·∫¨P DATABASE MYSQL")
    print("=" * 40)
    print("1. C√†i ƒë·∫∑t MySQL Server")
    print("2. T·∫°o database 'face_recognition'")
    print("3. C√†i ƒë·∫∑t mysql-connector-python:")
    print("   py -m pip install mysql-connector-python")
    print()
    
    host = input("üåê MySQL Host (localhost): ").strip() or "localhost"
    user = input("üë§ MySQL User (root): ").strip() or "root"
    password = input("üîê MySQL Password: ").strip()
    database = input("üóÑÔ∏è Database name (face_recognition): ").strip() or "face_recognition"
    
    return host, user, password, database

def main():
    print("üéØ H·ªá th·ªëng Qu√©t Khu√¥n m·∫∑t - Database MySQL")
    print("=" * 50)
    
    # Thi·∫øt l·∫≠p database
    host, user, password, database = setup_database()
    
    # Kh·ªüi t·∫°o h·ªá th·ªëng
    system = FaceDatabaseSystem()
    
    # K·∫øt n·ªëi database
    if not system.connect_database(host, user, password, database):
        print("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi database!")
        return
    
    # T·∫°o b·∫£ng
    if not system.create_database_tables():
        print("‚ùå Kh√¥ng th·ªÉ t·∫°o b·∫£ng!")
        return
    
    try:
        while True:
            print("\nüìã MENU CH√çNH:")
            print("1. üìπ Qu√©t khu√¥n m·∫∑t tr·ª±c ti·∫øp")
            print("2. üìä Xem th·ªëng k√™ database")
            print("3. ‚ùå Tho√°t")
            
            choice = input("\nüëâ Ch·ªçn (1-3): ").strip()
            
            if choice == '1':
                system.scan_faces_live()
            elif choice == '2':
                system.view_database_stats()
            elif choice == '3':
                break
            else:
                print("‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!")
                
    finally:
        system.close_connection()
        print("üëã T·∫°m bi·ªát!")

if __name__ == "__main__":
    main()
